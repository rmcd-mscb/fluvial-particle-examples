---
title: "Quickstart"
description: "Run your first fluvial-particle simulation in 5 minutes"
---

## Overview

This tutorial walks you through running a basic particle tracking simulation using pre-computed velocity fields from a hydrodynamic model.

## Prerequisites

Make sure you have pixi installed and dependencies set up:

```bash
pixi install
```

## Step 1: Prepare Your Configuration

First, let's get the default configuration as a dictionary. The `get_default_config()` function returns a complete configuration with all available options:

```{python}
from pathlib import Path
from fluvial_particle import get_default_config

# Get the default configuration as a nested dictionary
config = get_default_config()

# View the structure
for section, values in config.items():
    print(f"[{section}]")
    if isinstance(values, dict):
        for key, val in values.items():
            if isinstance(val, dict):
                print(f"  [{section}.{key}]")
            else:
                print(f"  {key} = {val}")
    print()
```

Now customize the configuration for our example data. With dictionary-based config, you can modify values directly:

```{python}
# Define paths to our example data
data_dir = Path("../../data/grids/FaSTMECH_straight")
file_2d = str(data_dir / "Result_straight_2d_1.vts")
file_3d = str(data_dir / "Result_straight_3d_1.vts")

# Customize grid settings
config["grid"]["file_2d"] = file_2d
config["grid"]["file_3d"] = file_3d
config["grid"]["track_3d"] = True

# Customize particle settings
config["particles"]["count"] = 50
config["particles"]["start_location"] = [10.0, 0.0, 0.5]

# Customize simulation timing
config["simulation"]["time"] = 60.0
config["simulation"]["print_interval"] = 5.0

print("Configuration updated!")
print(f"  Grid 2D: {config['grid']['file_2d']}")
print(f"  Particles: {config['particles']['count']}")
print(f"  Start location: {config['particles']['start_location']}")
```

::: {.callout-tip}
## Optional: Save configuration to file

You can save the configuration to a TOML file for reuse or CLI execution:

```python
from fluvial_particle import save_config

save_config(config, "settings.toml")
```

Or generate a template from the command line:

```bash
fluvial_particle --init              # Creates settings.toml (TOML format)
fluvial_particle --init --format python  # Legacy Python format
```
:::

## Step 2: Explore Your Grid Data

Before running a simulation, use `inspect_grid` to understand your input data. This function requires a settings file, so we'll save our config first:

```{python}
from fluvial_particle import inspect_grid, save_config

# Save config to a temporary file for inspection
settings_path = Path("settings_temp.toml")
save_config(config, settings_path)

# Inspect the grid - prints summary and returns detailed info
info = inspect_grid(settings_path)
```

The returned dictionary contains all the information programmatically:

```{python}
# Access specific information
print(f"\nGrid dimensions: {info['grid_2d']['dimensions']}")
print(f"Mean depth: {info['hydraulics']['depth']['mean']:.3f} m")
print(f"Mean velocity: {info['hydraulics']['velocity_mag']['mean']:.3f} m/s")
print(f"u* method: {info['ustar_method']}")
print(f"Available 2D scalars: {info['grid_2d']['scalars']}")
```

## Step 3: Run the Simulation

The `run_simulation` function accepts either a config dictionary or a file path:

```{python}
from fluvial_particle import run_simulation

# Create output directory
output_dir = Path("outputs/quickstart")
output_dir.mkdir(parents=True, exist_ok=True)

# Run simulation directly with config dict - no file needed!
results = run_simulation(
    config,  # Pass dict directly
    output_dir=output_dir,
    seed=12345,  # For reproducibility
)

print(f"Simulation complete!")
print(f"Output directory: {results.output_dir}")
```

### Alternative: Using the CLI

For batch processing or scripts, save the config to a file first:

```bash
# Using a TOML settings file
pixi run fluvial_particle settings.toml outputs/quickstart
```

## Step 4: Analyze Results

The `SimulationResults` object provides easy access to output data:

```{python}
# Show summary
print(results.summary())
```

```{python}
# Load trajectories as a DataFrame
df = results.to_dataframe()
print(f"Trajectory data shape: {df.shape}")
print(f"Columns: {list(df.columns)}")
df.head()
```

```{python}
# Get particle positions at specific times
positions = results.get_positions()
print(f"Position array shape: {positions.shape}")  # (timesteps, particles, 3)
print(f"Number of timesteps: {len(results.times)}")
print(f"Time range: {results.times[0]:.1f} to {results.times[-1]:.1f} seconds")
```

## Step 5: Visualize Trajectories

```{python}
import matplotlib.pyplot as plt
import numpy as np

# Get positions
positions = results.get_positions()
times = results.times

# Plot particle trajectories (x-y plane)
fig, axes = plt.subplots(1, 2, figsize=(12, 4))

# Left: X-Y trajectories
ax1 = axes[0]
for i in range(min(10, positions.shape[1])):
    ax1.plot(positions[:, i, 0], positions[:, i, 1], alpha=0.6, linewidth=0.8)
ax1.set_xlabel("x (m)")
ax1.set_ylabel("y (m)")
ax1.set_title("Particle Trajectories (Plan View)")
ax1.set_aspect('equal')

# Right: X position over time
ax2 = axes[1]
for i in range(min(10, positions.shape[1])):
    ax2.plot(times, positions[:, i, 0], alpha=0.6, linewidth=0.8)
ax2.set_xlabel("Time (s)")
ax2.set_ylabel("x position (m)")
ax2.set_title("Downstream Transport")

plt.tight_layout()
plt.show()
```

```{python}
# Vertical distribution over time (for 3D simulations)
# Check if we have meaningful z variation (3D tracking)
if positions[:, :, 2].std() > 0.01:
    fig, ax = plt.subplots(figsize=(10, 4))

    # Color by time
    colors = plt.cm.viridis(np.linspace(0, 1, len(times)))

    for t_idx in range(0, len(times), 2):  # Every other timestep
        z_positions = positions[t_idx, :, 2]
        ax.scatter(
            [times[t_idx]] * len(z_positions),
            z_positions,
            c=[colors[t_idx]],
            alpha=0.3,
            s=10
        )

    ax.set_xlabel("Time (s)")
    ax.set_ylabel("z position (m)")
    ax.set_title("Vertical Distribution Over Time")
    plt.show()
```

## Step 6: PyVista 3D Visualization (Optional)

For interactive 3D visualization, use PyVista. The `SimulationResults` class provides helper methods that return PyVista-compatible objects.

### Particle Point Cloud

```{python}
import pyvista as pv

# Set backend for notebooks
pv.set_jupyter_backend('static')  # Use 'trame' for interactive

# Convert results to PyVista PolyData
particles = results.to_pyvista(timestep=-1)

print(f"Points: {particles.n_points}")
print(f"Available arrays: {list(particles.point_data.keys())}")
```

```{python}
# Load the input grid (using path from earlier)
grid_2d = pv.read(file_2d)

# Create visualization with particles overlaid on grid
plotter = pv.Plotter()
plotter.add_mesh(
    grid_2d,
    scalars="Velocity (magnitude)",
    cmap="viridis",
    opacity=0.8,
    scalar_bar_args={"title": "Velocity (m/s)"}
)
plotter.add_points(
    particles,
    scalars="depth",
    cmap="plasma",
    point_size=12,
    render_points_as_spheres=True,
    scalar_bar_args={"title": "Depth at particle (m)"}
)
plotter.view_xy()
plotter.show()
```

### Particle Trajectories

```{python}
# Get trajectories as connected lines
trajectories = results.trajectories_to_pyvista()

print(f"Total points: {trajectories.n_points}")
print(f"Number of trajectories: {trajectories.n_lines}")
```

```{python}
# Plot trajectories colored by time
plotter = pv.Plotter()
plotter.add_mesh(grid_2d, scalars="Depth", cmap="Blues", opacity=0.5)
plotter.add_mesh(
    trajectories,
    scalars="time",
    cmap="viridis",
    line_width=3,
    scalar_bar_args={"title": "Time (s)"}
)
plotter.view_xy()
plotter.show()
```

### Specific Particle Trajectories

```{python}
# Get trajectories for specific particles
selected_traj = results.trajectories_to_pyvista(particle_ids=[0, 5, 10, 15, 20])

plotter = pv.Plotter()
plotter.add_mesh(grid_2d, color="lightgray", opacity=0.3)
plotter.add_mesh(
    selected_traj,
    scalars="particle_id",
    cmap="tab10",
    line_width=4,
    scalar_bar_args={"title": "Particle ID"}
)
plotter.view_xy()
plotter.show()
```

## Step 7: Output Files

The simulation creates several output files for further analysis:

```{python}
# List output files
print("Output files:")
for f in sorted(output_dir.iterdir()):
    if f.is_file():
        size = f.stat().st_size / 1024  # KB
        print(f"  {f.name}: {size:.1f} KB")
```

| File | Description |
|------|-------------|
| `particles.h5` | HDF5 file with particle trajectories |
| `particles.xmf` | XDMF metadata for ParaView |
| `cells.h5` | Cell-centered statistics |
| `cells_*.xmf` | Cell XDMF files |

Open `particles.xmf` in ParaView for 3D visualization.

## Summary

Key functions for notebook workflows:

| Function | Purpose |
|----------|---------|
| `get_default_config()` | Get configuration as editable dictionary |
| `save_config()` | Save config dict to TOML file |
| `inspect_grid()` | Explore grid data before simulation |
| `run_simulation()` | Run simulation from config dict or file |
| `SimulationResults` | Access and analyze output data |

### Configuration Pattern for Notebooks

The recommended pattern for notebooks is:

1. **Get default config** - `config = get_default_config()`
2. **Modify as needed** - `config["particles"]["count"] = 200`
3. **Run directly** - `results = run_simulation(config, output_dir)`

```python
# Clean notebook workflow - no files needed!
from fluvial_particle import get_default_config, run_simulation

config = get_default_config()
config["grid"]["file_2d"] = "./mesh_2d.vts"
config["grid"]["file_3d"] = "./mesh_3d.vts"
config["particles"]["count"] = 100
config["particles"]["start_location"] = [10.0, 0.0, 0.5]

results = run_simulation(config, "./output", seed=42)
```

### Configuration Sections

The configuration dictionary has these main sections:

| Section | Key Settings |
|---------|--------------|
| `simulation` | `time`, `dt`, `print_interval` |
| `particles` | `type`, `count`, `start_location` |
| `particles.physics` | `beta`, `lev`, `min_depth`, `vertical_bound` |
| `particles.falling` | `radius`, `density` (for FallingParticles) |
| `particles.larval` | `amplitude`, `period` (for LarvalParticles) |
| `grid` | `track_3d`, `file_2d`, `file_3d` |
| `grid.field_map_2d` | Map model field names to standard names |
| `grid.field_map_3d` | Map 3D field names |
| `output` | `vtp` (optional VTP output) |

See the [Configuration Reference](../../docs/optionsfile.qmd) for complete documentation.

## Next Steps

- [Configuration Reference](options_file.qmd) - All configuration options
- [Time-Varying Grids](../time_varying/unsteady_flow.qmd) - Unsteady flow simulations
- [ParaView Visualization](../visualization/paraview.qmd) - 3D visualization
